# The Search for the Holy Grail
An opinionated overview of the many (and in my view, the best) ways to build an application.

## Why?
If you were to set up an ideal application development platform which one would you choose?

I have been a developer or an architect for 40-ish years. I have seen the innards of countless systems written in a mind-numbing number of technologies and platforms. The most common feature of these systems is that they are overly complicated for what they do. This means they cost more to develop and maintain. They also have more bugs and are more likely to break under stress or change.

This review asks one question: 

> How can I build an application with the minimum amount of effort and complexity?

Complexity is the biggest problem in application development. Yet we often compound it with overly complicated frameworks and rituals that limit our ability to write good code.

## Legend
The following symbols are used in the tables:
| Symbol | Descripton |
|:------:| ---------- |
| â˜… | Github stars, a rough indicator or popularity |
| ðŸ’— | I like this |
| âŽ | Do not adopt, there is some gotcha or other problem |
| â–¶ | Standard technology, should adopt even if I do not like it. |
| âš‘ | This looks interesting. I should look into at some point. |

## Table of contents
1. [Wish List](WishList.md)
2. [Approach](Approach.md)
3. [Technology Stack](TechStack.md)
4. [Anatomy of a Web Application](Anatomy.md)
5. Client Platform
    1. [Team Dogma](PlatformDogma.md)
	2. [IDE](PlatformIDE.md)
	3. [Repository](PlatformRepository.md)
	4. [Language](PlatformLanguage.md)
	5. [Rendering Engine](PlatformRendering.md)
	6. [Visual Design](PlatformVisualDesign.md#design) 
	7. [Widget Catalog](PlatformVisualDesign.md#catalog) 
	8. [Widget Structure](PlatformVisualDesign.md#structure)
	9. [Build Tools](PlatformBuild.md)
6. Quality
	1. Code Linting
	2. Unit Tests
	3. Integration Tests
	5. End-to-End Tests
	4. Code Coverage
	6. SPA Compliance
	7. Code Size
	8. Profiling
	9. Legacy Support
	10. Server Side Rendering
7. Server
	1. Server Interface
	2. Database
	3. Reverse Proxy
	4. Authentication
	5. External Login
	6. Authorization
	7. Secure Socket
	8. CORS Support
	9. Logging
	10. Log Browser
	11. Load Balancer
	12. Rate Limiting
	13. Analytics
	14. SEO
8. Deployment
	1. Containers
	2. Container Orchestration
	3. Host Server

[Next> WishList](WishList.md)
